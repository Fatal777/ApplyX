/**
 * LiveKit Service
 * Handles LiveKit room creation, token generation, and interview lifecycle
 * for the v1.3 real-time mock-interview experience.
 */

import { supabase } from '@/lib/supabase';

const API_BASE_URL = (import.meta.env.VITE_API_URL || 'http://localhost:8000') + '/api/v1';

export interface LiveKitToken {
    token: string;
    url: string;
    room_name: string;
}

export interface LiveKitStatus {
    configured: boolean;
    url?: string;
}

export interface StartInterviewParams {
    job_role?: string;
    difficulty?: string;
    persona?: string;
    interview_type?: string;
    num_questions?: number;
    resume_summary?: string;
    job_description?: string;
}

export interface StartInterviewResult {
    token: string;
    url: string;
    room_name: string;
    session_id: string;
}

export interface FeedbackPollResult {
    status: 'pending' | 'ready' | 'error';
    session_id?: string;
    feedback?: {
        overall_score: number;
        category_scores: Record<string, number>;
        strengths: string[];
        improvements: string[];
        detailed_feedback: string | Record<string, string>;
        recommendations: string[];
        generated_at: string;
    };
    error?: string;
}

class LiveKitService {
    private baseUrl: string;

    constructor() {
        this.baseUrl = API_BASE_URL;
    }

    /**
     * Get auth headers for API requests
     */
    private async getAuthHeaders(): Promise<HeadersInit> {
        const { data: { session } } = await supabase.auth.getSession();
        return {
            'Content-Type': 'application/json',
            ...(session?.access_token && {
                'Authorization': `Bearer ${session.access_token}`
            })
        };
    }

    /**
     * Check if LiveKit is configured on the server
     */
    async checkStatus(): Promise<LiveKitStatus> {
        try {
            const response = await fetch(`${this.baseUrl}/livekit/status`);
            if (!response.ok) {
                return { configured: false };
            }
            return await response.json();
        } catch (error) {
            console.error('Failed to check LiveKit status:', error);
            return { configured: false };
        }
    }

    /**
     * Get a room token for joining an existing room
     */
    async getRoomToken(roomName: string, participantName?: string): Promise<LiveKitToken> {
        const headers = await this.getAuthHeaders();

        const response = await fetch(`${this.baseUrl}/livekit/token`, {
            method: 'POST',
            headers,
            body: JSON.stringify({
                room_name: roomName,
                participant_name: participantName,
            }),
        });

        if (!response.ok) {
            const error = await response.json().catch(() => ({ detail: 'Failed to get token' }));
            throw new Error(error.detail || 'Failed to get LiveKit token');
        }

        return await response.json();
    }

    /**
     * Create a LiveKit room with interview config, start agent dispatch,
     * and return the participant token + room details.
     */
    async startInterview(params: StartInterviewParams = {}): Promise<StartInterviewResult> {
        const headers = await this.getAuthHeaders();

        const response = await fetch(`${this.baseUrl}/livekit/start-interview`, {
            method: 'POST',
            headers,
            body: JSON.stringify(params),
        });

        if (!response.ok) {
            const error = await response.json().catch(() => ({ detail: 'Failed to start interview' }));
            throw new Error(error.detail || 'Failed to start interview');
        }

        return await response.json();
    }

    /**
     * Signal that the interview is complete (triggers backend cleanup / feedback).
     */
    async endInterview(roomName: string, sessionId: string): Promise<void> {
        const headers = await this.getAuthHeaders();

        const response = await fetch(`${this.baseUrl}/livekit/end-interview`, {
            method: 'POST',
            headers,
            body: JSON.stringify({ room_name: roomName, session_id: sessionId }),
        });

        if (!response.ok) {
            console.warn('end-interview request failed:', response.status);
        }
    }

    /**
     * Poll for feedback generated by the Gradient evaluation agent.
     * Returns { status: 'pending' | 'ready' | 'error', feedback?: object }
     */
    async getFeedback(sessionId: string): Promise<FeedbackPollResult> {
        const headers = await this.getAuthHeaders();

        const response = await fetch(`${this.baseUrl}/livekit/feedback/${sessionId}`, {
            headers,
        });

        if (!response.ok) {
            return { status: 'error' };
        }

        return await response.json();
    }

    /**
     * Poll for feedback until it's ready (or timeout after maxAttempts).
     */
    async waitForFeedback(
        sessionId: string,
        intervalMs = 2000,
        maxAttempts = 30,
    ): Promise<FeedbackPollResult> {
        for (let i = 0; i < maxAttempts; i++) {
            const result = await this.getFeedback(sessionId);
            if (result.status !== 'pending') return result;
            await new Promise((r) => setTimeout(r, intervalMs));
        }
        return { status: 'error', error: 'Feedback generation timed out' };
    }
}

export const liveKitService = new LiveKitService();
export default liveKitService;
